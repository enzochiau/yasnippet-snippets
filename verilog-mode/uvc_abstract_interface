# -*- mode: snippet; require-final-newline: nil -*-
# name: UVC abstract interface
# key: uvc_abs_if
# group: UVC
# --

\`ifndef ${1:$(upcase yas-text)}_INTERFACE__SV
\`define ${1:$(upcase yas-text)}_INTERFACE__SV

interface ${1:`(get-pkg-name (get-buffer-name))`}_if #(string P_PROC="$1"${2:, int P_DWIDTH = 15})
   (input bit clk, input bit rst);

   import $1_abstract_pkg::*;

   $0
   
   // bit [P_DWIDTH-1:0] din;
   // bit                dinVld;
   // bit                dc;

class concrete_c extends $1_abstract_c;
   function new(string name="");
      super.new(name);
   endfunction : new

   // Wait for signals
   task wait_for_reset();
      if (!rst)
        @(posedge rst);
   endtask : wait_for_reset

   task wait_for_reset_release();
      if (rst)
        @(negedge rst);
   endtask : wait_for_reset_release

   task wait_for_clock(int n=1);
      repeat(n)
        @(posedge clk);
   endtask : wait_for_clock

   task reset_signals();
      wait_for_reset;
      // dinVld <= 0;
      // din    <= 0;
      // dc     <= 0;
      @(posedge clk);
      wait_for_reset_release;
   endtask : reset_signals

   task write(int data);
      // dinVld <= 1;
      // din    <= data;
      // dc     <= is_dc;
      // @(posedge clk);
      // dinVld <= 0;
      // dc     <= 0;
   endtask : write
   
   task read(int data);
      // dinVld <= 1;
      // din    <= data;
      // dc     <= is_dc;
      // @(posedge clk);
      // dinVld <= 0;
      // dc     <= 0;
   endtask : read

endclass

   concrete_c concrete_inst;
   function $1_abstract_c get_concrete_c_inst();
      concrete_inst=new(P_PROC);
      return concrete_inst;
   endfunction // get_concrete_c_inst

endinterface : $1_if

\`endif // \`ifndef ${1:$(upcase yas-text)}_INTERFACE__SV